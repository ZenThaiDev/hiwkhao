use std::fs;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    let lex_file = "hiwkhao.lex";
    let output_file = "./scanner/src/grammar.rs";

    let lines = read_lines(lex_file).expect("Failed to read the .lex file");

    let mut rust_code = String::from(
        r#"// This file is auto-generated by the preprocessor
// The preprocessor reads the .lex file and generates the Rust code for logos
// To regenerate this file, run the preprocessor with the following command:
// cargo run -p preprocessor
        
use logos::Logos;
use std::fmt;

#[derive(Logos, Clone, Debug, PartialEq)]
pub enum Token {
"#,
    );

    for line in lines {
        if let Ok(entry) = line {
            let parts: Vec<&str> = entry.splitn(2, ' ').collect();
            if parts.len() == 2 {
                let token_type = parts[0];
                let regex = parts[1].trim();

                // Handle special cases where we want to generate a function-like enum variant
                if ["REAL", "INT"].contains(&token_type) {
                    rust_code.push_str(&format!(
                        r#"    #[regex(r"{regex}", |lex| lex.slice().parse().map_err(|_| ()))]
        {token_type}(String),"#,
                        regex = regex,
                        token_type = token_type
                    ));
                } else if ["VAR"].contains(&token_type) {
                    rust_code.push_str(&format!(
                        r#"    #[regex(r"{regex}", |lex| lex.slice().to_string(), priority = 2)]
        {token_type}(String),"#,
                        regex = regex,
                        token_type = token_type
                    ));
                } else if token_type == "WHITESPACE" {
                    rust_code.push_str(&format!(
                        r#"    #[regex(r"{regex}", logos::skip, priority = 1)]
        {token_type},"#,
                        regex = regex,
                        token_type = token_type
                    ));
                } else {
                    rust_code.push_str(&format!(
                        r#"    #[regex(r"{regex}")]
        {token_type},"#,
                        regex = regex,
                        token_type = token_type
                    ));
                }
                rust_code.push_str("\n");
            }
        }
    }

    rust_code.push_str("    #[allow(dead_code)]\n    ERR,\n");

    rust_code.push_str("}\n");

    let display = String::from(
        r#"
impl fmt::Display for Token {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::REAL(s) => write!(f, "{}", s),
            Self::INT(s) => write!(f, "{}", s),
            Self::VAR(s) => write!(f, "{}", s),
            Self::ADD => write!(f, "+"),
            Self::SUB => write!(f, "-"),
            Self::MUL => write!(f, "*"),
            Self::DIV => write!(f, "/"),
            Self::INTDIV => write!(f, "//"),
            Self::POW => write!(f, "^"),
            Self::LPAREN => write!(f, "("),
            Self::RPAREN => write!(f, ")"),
            Self::LBRACKET => write!(f, "["),
            Self::RBRACKET => write!(f, "]"),
            Self::EQ => write!(f, "=="),
            Self::NE => write!(f, "!="),
            Self::LE => write!(f, "<="),
            Self::GE => write!(f, ">="),
            Self::LT => write!(f, "<"),
            Self::GT => write!(f, ">"),
            Self::ASSIGN => write!(f, "="),
            Self::LIST => write!(f, "list"),
            Self::WHITESPACE => write!(f, "<whitespace>"),
            Self::ERR => write!(f, "<error>"),
            Self::NEWLINE => write!(f, "<newline>"),
        }
    }
}
"#,
    );

    rust_code.push_str(&display);

    fs::write(output_file, rust_code).expect("Failed to write the generated Rust file");

    println!("Logos-compatible Rust code generated in: {}", output_file);
}

fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<fs::File>>>
where
    P: AsRef<Path>,
{
    let file = fs::File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
